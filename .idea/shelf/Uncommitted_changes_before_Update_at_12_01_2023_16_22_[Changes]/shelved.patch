Index: Optimized_dynamic_tether_sim.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>import numpy as np\r\nimport matplotlib.pyplot as plt\r\nimport matplotlib.animation as animation\r\nimport Wind_loading_generations as Wind_l\r\nimport scipy as sc\r\nimport ISA_general\r\n\r\nnodes = 50\r\nh_balloon = 20000  # m\r\nh_ground = 0  # m\r\nL_excess = 8000  # N\r\nD = 4000  # N\r\ndensity = 950  # kg/m^3\r\nr = 0.008  # m\r\nCd = 0.3\r\nE = 100e9  # Pa\r\ng = 9.81  # m/s\r\nC = 4  # Ns/m\r\n\r\nL_tandem = 2400  # Lift force [N] of the tandem balloon\r\nD_tandem = 400  # Drag force [N] of the tandem balloon\r\nloc_lst = [0.1,0.2,0.3,0.4,0.5,0.6,0.7,0.8,0.9]  # Fractions of the tether where the tandem balloon is located\r\n\r\n# Initiate nodes\r\ny = np.linspace(h_ground, h_balloon, nodes)  # altitude\r\nx = np.zeros(nodes)  # x pos\r\nFx = np.zeros(nodes)  # sum of x forces on node\r\nFy = np.zeros(nodes)  # sum of y forces on node\r\nFtandx = np.zeros(nodes)\r\nFtandy = np.zeros(nodes)\r\nvx = np.zeros(nodes)  # node velocity\r\nvy = np.zeros(nodes)\r\nax = np.zeros(nodes)  # node acceleration\r\nay = np.zeros(nodes)\r\nxframes = np.zeros((1, nodes))\r\nyframes = np.zeros((1, nodes))\r\ntheta_nodes = np.zeros(nodes)\r\n\r\n# Initiate segments\r\nsegments = nodes - 1\r\nL0 = (h_balloon - h_ground) / segments  # length of a segment\r\ncrossA = r ** 2 * np.pi  # m^2\r\nS_front = 2 * r * L0\r\ntheta = np.arctan(np.zeros(segments))\r\nT = np.zeros(segments)\r\n\r\n# Initiate node mass and weight (first and last node have half the mass of the rest)\r\nm = L0 * crossA * density * np.ones(nodes)\r\nm[0] = m[0] * 0.5\r\nm[-1] = m[-1] * 0.5\r\nW = m * g\r\n\r\n# Set up animation\r\n# Create the figure and axes to animate\r\nfig, axs = plt.subplots(1)\r\n\r\n\r\n# init_func() is called at the beginning of the animation\r\ndef init_func():\r\n    axs.clear()\r\n\r\n\r\n# update_plot() is called between frames\r\ndef update_plot(i):\r\n    axs.clear()\r\n    axs.plot(xframes[i, :], yframes[i, :], color='k')\r\n\r\n\r\n# Create tandem balloon force\r\nnode_lst = []\r\nfor loc in loc_lst:\r\n    tandem_node = round(nodes * loc) - 1\r\n    node_lst.append(tandem_node)\r\n    Ftandx[tandem_node] = D_tandem\r\n    Ftandy[tandem_node] = L_tandem\r\nL = L_excess + np.sum(W) - len(loc_lst) * L_tandem\r\n\r\nR = 8.31446261815324 # J/K/mol\r\nMH2 = 2 * 1.00784 # u = g/mol\r\nRH2 = R/MH2 # J/K/mol / [g/mol] = J*mol/K/mol/g = J/K/g = kJ/K.kg\r\ndef tandem_volume(h,l):\r\n    T, p, rho = ISA_general.ISA(h)\r\n    rhoH = p/RH2/T # [J/m3] / [kJ/kg.K] / [K] = [J/m3].[kg] / [kJ] = [kg/m3]/[J/kJ] = [g/m3]\r\n    rhoH = rhoH/1000\r\n    # print(rhoH)\r\n\r\n    rhodif = rho-rhoH # [kg/m3], Difference in weight between air and hydrogen at altitude h\r\n    L_over_V = rhodif * g # [N/m3], lift force per m3 of hydrogen\r\n    V = l/L_over_V\r\n    return V, rho\r\n\r\ndef update_tandem(cd_tandem):\r\n    for i in range(len(loc_lst)):\r\n        vol, rho = tandem_volume(y[node_lst[i]], L_tandem)\r\n        R = (vol * 3 / 4 / np.pi) ** (1/3)\r\n        D_tandem = cd_tandem * 0.5 * rho * (wind_speed[node_lst[i]] - vx[node_lst[i]]) * abs((wind_speed[node_lst[i]] - vx[node_lst[i]])) * np.pi * R ** 2\r\n        Ftandx[tandem_node] = D_tandem\r\n\r\n\r\n# Interpolate the wind profile function\r\ndataset = np.array([[-1000, 0],\r\n                    [0, 11],\r\n                    [2500, 15],\r\n                    [5000, 29],\r\n                    [7500, 41],\r\n                    [10000, 51],\r\n                    [12000, 43],\r\n                    [13500, 32],\r\n                    [16000, 20],\r\n                    [17000, 11],\r\n                    [20000, 9],\r\n                    [23000, 11],\r\n                    [25500, 15]])\r\nyset = 0.6 * dataset[:, 1]  # wind speed [m/s], about 30 m/s maximum\r\nxset = dataset[:, 0]  # altitude [m]\r\nwindspeed_from_alt = sc.interpolate.interp1d(xset, yset, kind='quadratic')\r\n\r\n# Set up simulation\r\nt = 0\r\ndt = 0.001\r\nt_end = 200\r\nmax_stress = 0\r\nmax_v = 0\r\ncounter = 0\r\nwhile t < t_end:  # and np.any(abs(ax) > 0.1):\r\n\r\n    if np.all(abs(ax) < 0.01) and np.all(abs(vx) < 0.1) and t > 30:\r\n        print(\"Break because of low acceleration and speed\")\r\n        break\r\n\r\n    t += dt\r\n    counter += 1\r\n    if counter % 1000 == 0:\r\n        print(f\"Has run {counter} loops\")\r\n        xframes = np.append(xframes, [x], axis=0)\r\n        yframes = np.append(yframes, [y], axis=0)\r\n\r\n    # Calculate tension forces in all segments\r\n    T = crossA * E / L0 * (np.sqrt((y[1:] - y[:-1]) ** 2 + (x[1:] - x[:-1]) ** 2) - L0)\r\n    theta = np.arctan2((x[1:] - x[:-1]), (y[1:] - y[:-1]))\r\n\r\n    Tx = T * np.sin(theta)\r\n    Ty = T * np.cos(theta)\r\n\r\n    if np.max(T / crossA) > max_stress:\r\n        max_stress = np.max(T / crossA)\r\n        max_node = np.argmax(T / crossA)\r\n        tmax = t\r\n\r\n    if np.max(vx) > max_v:\r\n        max_v = np.max(vx)\r\n        tmaxv = t\r\n\r\n    # Calculate wind force\r\n    theta_nodes[0] = theta[0]\r\n    theta_nodes[1:-1] = (theta[1:] + theta[:-1]) / 2\r\n    theta_nodes[-1] = theta[-1]\r\n\r\n    wind_speed = windspeed_from_alt(y)\r\n    wind_perp = wind_speed * np.cos(theta_nodes)\r\n    wind_par = wind_speed * np.sin(theta_nodes)\r\n    Fperp = Wind_l.calc_drag_on_wire(x, y, wind_perp, L0, r, Cd)\r\n    Fperpx = Fperp * np.cos(theta_nodes)\r\n    Fperpy = Fperp * np.sin(theta_nodes)\r\n\r\n    Fpar = Wind_l.calc_drag_on_wire(x, y, wind_par, L0, r, Cd)\r\n    Fparx = Fpar * np.sin(theta_nodes)\r\n    Fpary = Fpar * np.cos(theta_nodes)\r\n\r\n    # Calculate resisting forces\r\n    Fresx = C * vx\r\n    Fresy = C * vy\r\n\r\n    # Calculate total forces on all nodes\r\n    Fx[0] = Tx[0] + Fperpx[0] / 2 - Fresx[0] + Fparx[0]/ 2\r\n    Fy[0] = Ty[0] - W[0] - Fresy[0] - Fperpy[0]/2 + Fpary[0]/2\r\n    Fx[1:-1] = Tx[1:] - Tx[0:-1] + Fperpx[1:-1] - Fresx[1:-1] + Fparx[1:-1]\r\n    Fy[1:-1] = Ty[1:] - Ty[0:-1] - W[1:-1] - Fresy[1:-1] - Fperpy[1:-1] + Fpary[1:-1]\r\n    Fx[-1] = D + Fperpx[-1] / 2 - Tx[-1] - Fresx[-1] + Fparx[-1]/ 2\r\n    Fy[-1] = L - Ty[-1] - W[-1] - Fresy[-1] - Fperpy[-1]/2 + Fpary[-1]/ 2\r\n\r\n    # Add tandem forces\r\n    if counter % 100 == 0:\r\n        update_tandem(0.3)\r\n    Fx = Fx + Ftandx\r\n    Fy = Fy + Ftandy\r\n\r\n    ax[1:] = Fx[1:] / m[1:] * min(t, 1)\r\n    ay[1:] = Fy[1:] / m[1:] * min(t, 1)\r\n    Rx = -Fx\r\n    Ry = -Fy\r\n\r\n    vx = vx + ax * dt\r\n    vy = vy + ay * dt\r\n\r\n    x = x + vx * dt\r\n    y = y + vy * dt\r\n\r\nanim = animation.FuncAnimation(fig, update_plot, frames=xframes.shape[0], init_func=init_func)\r\nplt.show()\r\n\r\n# print(xframes, yframes)\r\n# print('Fx,Fy = ', Fx, Fy)\r\nprint(T)\r\n# print(T/(crossA * E / L0) + L0)\r\n# print(T / crossA)\r\n# print('ax,ay = ', ax, ay)\r\n# print('vx,vy = ', vx, vy)\r\n# print('x,y = ', x, y)\r\n# print(theta)\r\n# print(np.sum(Fperpx))\r\nprint(f'Final location is ({x[-1]}, {y[-1]})')\r\nprint(f'Maximum stress is {max_stress} Pa at node {max_node} at {tmax} s')\r\nprint(f'Maximum speed is {max_v} Pa at {tmaxv} s')\r\nprint(f'Maximum stress in the steady solution is {np.max(T / crossA)} Pa at node {np.argmax(T / crossA)}')\r\n\r\nplt.plot(range(nodes - 1), T)\r\nplt.show()
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/Optimized_dynamic_tether_sim.py b/Optimized_dynamic_tether_sim.py
--- a/Optimized_dynamic_tether_sim.py	(revision d1bd42c1986881159ef52126a4623325e8c98ea6)
+++ b/Optimized_dynamic_tether_sim.py	(date 1673536741992)
@@ -9,17 +9,17 @@
 h_balloon = 20000  # m
 h_ground = 0  # m
 L_excess = 8000  # N
-D = 4000  # N
 density = 950  # kg/m^3
-r = 0.008  # m
+r = 0.005  # m
 Cd = 0.3
 E = 100e9  # Pa
 g = 9.81  # m/s
 C = 4  # Ns/m
+A = 593.2 # m^2 balloon frontal area
 
-L_tandem = 2400  # Lift force [N] of the tandem balloon
+L_tandem = 2000  # Lift force [N] of the tandem balloon
 D_tandem = 400  # Drag force [N] of the tandem balloon
-loc_lst = [0.1,0.2,0.3,0.4,0.5,0.6,0.7,0.8,0.9]  # Fractions of the tether where the tandem balloon is located
+loc_lst = []  # Fractions of the tether where the tandem balloon is located
 
 # Initiate nodes
 y = np.linspace(h_ground, h_balloon, nodes)  # altitude
@@ -80,9 +80,9 @@
 RH2 = R/MH2 # J/K/mol / [g/mol] = J*mol/K/mol/g = J/K/g = kJ/K.kg
 def tandem_volume(h,l):
     T, p, rho = ISA_general.ISA(h)
-    rhoH = p/RH2/T # [J/m3] / [kJ/kg.K] / [K] = [J/m3].[kg] / [kJ] = [kg/m3]/[J/kJ] = [g/m3]
+    rhoH = p/RH2/T # [J/m^3] / [kJ/kg.K] / [K] = [J/m3].[kg] / [kJ] = [kg/m3]/[J/kJ] = [g/m3]
     rhoH = rhoH/1000
-    # print(rhoH)
+
 
     rhodif = rho-rhoH # [kg/m3], Difference in weight between air and hydrogen at altitude h
     L_over_V = rhodif * g # [N/m3], lift force per m3 of hydrogen
@@ -118,7 +118,7 @@
 # Set up simulation
 t = 0
 dt = 0.001
-t_end = 200
+t_end = 10
 max_stress = 0
 max_v = 0
 counter = 0
@@ -150,6 +150,7 @@
     if np.max(vx) > max_v:
         max_v = np.max(vx)
         tmaxv = t
+        max_v_pos = np.argmax(vx)
 
     # Calculate wind force
     theta_nodes[0] = theta[0]
@@ -163,7 +164,7 @@
     Fperpx = Fperp * np.cos(theta_nodes)
     Fperpy = Fperp * np.sin(theta_nodes)
 
-    Fpar = Wind_l.calc_drag_on_wire(x, y, wind_par, L0, r, Cd)
+    Fpar = Wind_l.calc_drag_on_wire(x, y, wind_par, L0, r, 1.2)
     Fparx = Fpar * np.sin(theta_nodes)
     Fpary = Fpar * np.cos(theta_nodes)
 
@@ -171,6 +172,10 @@
     Fresx = C * vx
     Fresy = C * vy
 
+    # Calculate drag due to balloon
+
+    D = 0.5 * ISA_general.ISA(y[-1])[2] * (wind_speed[-1] - vx[-1]) * abs((wind_speed[-1] - vx[-1])) * A * 0.04
+
     # Calculate total forces on all nodes
     Fx[0] = Tx[0] + Fperpx[0] / 2 - Fresx[0] + Fparx[0]/ 2
     Fy[0] = Ty[0] - W[0] - Fresy[0] - Fperpy[0]/2 + Fpary[0]/2
@@ -196,12 +201,12 @@
     x = x + vx * dt
     y = y + vy * dt
 
-anim = animation.FuncAnimation(fig, update_plot, frames=xframes.shape[0], init_func=init_func)
+anim = animation.FuncAnimation(fig, update_plot, frames=xframes.shape[0], init_func=init_func, interval=100)
 plt.show()
 
 # print(xframes, yframes)
 # print('Fx,Fy = ', Fx, Fy)
-print(T)
+# print(T)
 # print(T/(crossA * E / L0) + L0)
 # print(T / crossA)
 # print('ax,ay = ', ax, ay)
@@ -211,8 +216,9 @@
 # print(np.sum(Fperpx))
 print(f'Final location is ({x[-1]}, {y[-1]})')
 print(f'Maximum stress is {max_stress} Pa at node {max_node} at {tmax} s')
-print(f'Maximum speed is {max_v} Pa at {tmaxv} s')
+print(f'Maximum speed is {max_v} m/s at {tmaxv} s and node {max_v_pos}')
 print(f'Maximum stress in the steady solution is {np.max(T / crossA)} Pa at node {np.argmax(T / crossA)}')
-
+print(f'{D}')
 plt.plot(range(nodes - 1), T)
-plt.show()
\ No newline at end of file
+plt.show()
+print(nodes, len(T))
\ No newline at end of file
Index: .idea/aws.xml
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/.idea/aws.xml b/.idea/aws.xml
new file mode 100644
--- /dev/null	(date 1673518747406)
+++ b/.idea/aws.xml	(date 1673518747406)
@@ -0,0 +1,11 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<project version="4">
+  <component name="accountSettings">
+    <option name="activeRegion" value="us-east-1" />
+    <option name="recentlyUsedRegions">
+      <list>
+        <option value="us-east-1" />
+      </list>
+    </option>
+  </component>
+</project>
\ No newline at end of file
Index: .idea/DSE_Group3_Q2_2022.iml
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+><?xml version=\"1.0\" encoding=\"UTF-8\"?>\r\n<module type=\"PYTHON_MODULE\" version=\"4\">\r\n  <component name=\"NewModuleRootManager\">\r\n    <content url=\"file://$MODULE_DIR$\">\r\n      <excludeFolder url=\"file://$MODULE_DIR$/venv\" />\r\n    </content>\r\n    <orderEntry type=\"jdk\" jdkName=\"Python 3.8 Global\" jdkType=\"Python SDK\" />\r\n    <orderEntry type=\"sourceFolder\" forTests=\"false\" />\r\n  </component>\r\n</module>
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/.idea/DSE_Group3_Q2_2022.iml b/.idea/DSE_Group3_Q2_2022.iml
--- a/.idea/DSE_Group3_Q2_2022.iml	(revision d1bd42c1986881159ef52126a4623325e8c98ea6)
+++ b/.idea/DSE_Group3_Q2_2022.iml	(date 1673518747419)
@@ -4,7 +4,7 @@
     <content url="file://$MODULE_DIR$">
       <excludeFolder url="file://$MODULE_DIR$/venv" />
     </content>
-    <orderEntry type="jdk" jdkName="Python 3.8 Global" jdkType="Python SDK" />
+    <orderEntry type="jdk" jdkName="Python 3.1" jdkType="Python SDK" />
     <orderEntry type="sourceFolder" forTests="false" />
   </component>
 </module>
\ No newline at end of file
Index: .idea/misc.xml
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+><?xml version=\"1.0\" encoding=\"UTF-8\"?>\r\n<project version=\"4\">\r\n  <component name=\"ProjectRootManager\" version=\"2\" project-jdk-name=\"Python 3.8 Global\" project-jdk-type=\"Python SDK\" />\r\n</project>
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/.idea/misc.xml b/.idea/misc.xml
--- a/.idea/misc.xml	(revision d1bd42c1986881159ef52126a4623325e8c98ea6)
+++ b/.idea/misc.xml	(date 1673518747431)
@@ -1,4 +1,4 @@
 <?xml version="1.0" encoding="UTF-8"?>
 <project version="4">
-  <component name="ProjectRootManager" version="2" project-jdk-name="Python 3.8 Global" project-jdk-type="Python SDK" />
+  <component name="ProjectRootManager" version="2" project-jdk-name="Python 3.1" project-jdk-type="Python SDK" />
 </project>
\ No newline at end of file
