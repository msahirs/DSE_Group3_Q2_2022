Index: dynamic tether simulation.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>import time\r\nimport matplotlib.animation as animation\r\nimport matplotlib.pyplot as plt\r\nimport numpy as np\r\nimport scipy as sc\r\nfrom matplotlib.animation import PillowWriter\r\n\r\nimport ISA_general\r\nimport Wind_loading_generations as Wind_l\r\n\r\n\r\ndef plot_response(x, y, loc_lists, end_tension_list, end_lift_list):\r\n    ax, fig = plt.subplots(1, 2, gridspec_kw={'width_ratios': [2, 1]})\r\n    global L\r\n    plt.subplot(1,2,1)\r\n    for item in range(len(x)):\r\n        label = f\"Tether {item + 1}, radius = {radius_items[item]} [m]\"\r\n        plt.plot(x[item][-1], y[item][-1], label=label, c=colorlist[item])\r\n        plt.plot(x[item][-1][-1], y[item][-1][-1], c=\"black\", marker=\".\", markersize=20, linestyle=\"None\")\r\n        for loc_frac in loc_lists[item]:\r\n            if loc_frac:\r\n                loc = round(loc_frac * len(x[item][-1]))\r\n                plt.plot(x[item][-1][loc], y[item][-1][loc], c=\"gray\", marker=\".\", markersize=10, linestyle=\"None\")\r\n    plt.xlabel(\"Horizontal distance [meters]\")\r\n    plt.ylabel(\"Altitude [meters]\")\r\n    plt.xlim(-100, 11000)\r\n    plt.legend(loc=\"lower right\")\r\n    plt.grid()\r\n    plt.title(f\"Final dynamic response\")\r\n    figure_name = f\"Final dynamic response to realistic windprofile, change on wire radius \"\r\n    plt.subplot(1, 2, 2)\r\n    for numb, end_tension in enumerate(end_tension_list):\r\n        rounded_lift = round(end_lift_list[numb]/1000, 2)\r\n        label = f\"Max tension = {round(max(end_tension) / 10 ** 6, 2)} \\nLift needed is going to be {rounded_lift} [kN]\"\r\n        plt.plot(end_tension / 10 ** 6, range(len(end_tension)), c=colorlist[numb], label=label)\r\n    plt.xlabel(\"Stress [Mpa]\")\r\n    # plt.ylabel(\"Node numb\")\r\n    plt.title(\"Max tension in nodes\")\r\n    plt.legend(loc=\"lower right\")\r\n    plt.grid()\r\n    plt.suptitle(\"Left, plot showing final steady state solution. Right showing tension over altitude\")\r\n    plt.savefig(\"./Figures/\" + figure_name + \".png\")\r\n    plt.show()\r\n\r\n\r\n# Interpolate the wind profile function\r\ndataset = np.array([[-100000, 0],\r\n                    [0, 11],\r\n                    [2500, 15],\r\n                    [5000, 29],\r\n                    [7500, 41],\r\n                    [10000, 51],\r\n                    [12000, 43],\r\n                    [13500, 32],\r\n                    [16000, 20],\r\n                    [17000, 11],\r\n                    [20000, 9],\r\n                    [23000, 11],\r\n                    [25500, 15]])\r\nyset = 0.6 * dataset[:, 1]  # wind speed\r\nxset = dataset[:, 0]  # altitude\r\nwindspeed_from_alt = sc.interpolate.interp1d(xset, yset, kind='quadratic')\r\n\r\ncolorlist = [\"turquoise\", \"indigo\", \"red\", \"lime\"]\r\n\r\n\r\ndef run_progamm(Cd=0.3, r=0.01, h_balloon=20000, nodes=50, loc_lst=[], dt=0.001):\r\n    R = 8.31446261815324  # J/K/mol\r\n    MH2 = 2 * 1.00784  # u = g/mol\r\n    RH2 = R / MH2  # J/K/mol / [g/mol] = J*mol/K/mol/g = J/K/g = kJ/K.kg\r\n\r\n    def tandem_volume(h, l):\r\n        Temp, pres, rho = ISA_general.ISA(h)\r\n        rhoH = pres / RH2 / Temp  # [J/m3] / [kJ/kg.K] / [K] = [J/m3].[kg] / [kJ] = [kg/m3]/[J/kJ] = [g/m3]\r\n        rhoH = rhoH / 1000\r\n\r\n        rhodif = rho - rhoH  # [kg/m3], Difference in weight between air and hydrogen at altitude h\r\n        L_over_V = rhodif * g  # [N/m3], lift force per m3 of hydrogen\r\n        V = l / L_over_V\r\n        return V, rho\r\n\r\n    def update_tandem(cd_tandem):\r\n        for i in range(len(loc_lst)):\r\n            vol, rho = tandem_volume(y[node_lst[i]], L_tandem)\r\n            R = (vol * 3 / 4 / np.pi) ** (1 / 3)\r\n            D_tandem = cd_tandem * 0.5 * rho * (wind_speed[node_lst[i]] - vx[node_lst[i]]) * abs(\r\n                (wind_speed[node_lst[i]] - vx[node_lst[i]])) * np.pi * R ** 2\r\n            Ftandx[tandem_node] = D_tandem\r\n\r\n    # nodes = 50\r\n    # h_balloon = 15000  # m\r\n    h_ground = 0  # m\r\n\r\n    # drag coeff for balloons\r\n    Frontal_area = 1225.2\r\n    Cd_top_balloon = 0.0112\r\n    Cd_tan_balloon = 0.2\r\n\r\n    # Create tandem balloon force\r\n    L_tandem = 2000  # Lift force [N] of the tandem balloon\r\n    D_tandem = 50\r\n    # loc_lst = [0.2]  # Fractions of the tether where the tandem balloon is located\r\n\r\n    rho_umpf = 950  # UHMWPE density, kg/m^3\r\n    rho_al = 70  # aluminium density, kg/m^3\r\n    A_umpf = 100e-6  # initial guess, m^2\r\n    A_al = 16e-6  # m^2\r\n    sigma_max = 250e6  # maximum allowable stress, Pa\r\n    # Cd = 1.2  # tether drag coeff\r\n    E = 100e9  # Pa\r\n    g = 9.81  # m/s\r\n    C = 0.1  # Ns/m\r\n    plot_wind = False\r\n\r\n    # Initiate nodes\r\n    y = np.linspace(h_ground, h_balloon, nodes)  # altitude\r\n    x = np.zeros(nodes)  # x pos\r\n    Fx = np.zeros(nodes)  # sum of x forces on node\r\n    Fy = np.zeros(nodes)  # sum of y forces on node\r\n    Ftandx = np.zeros(nodes)  # vector containing forces from tandem balloon in x\r\n    Ftandy = np.zeros(nodes)  # vector containing forces from tandem balloon in y\r\n    vx = np.zeros(nodes)  # node velocity\r\n    vy = np.zeros(nodes)\r\n    ax = np.zeros(nodes)  # node acceleration\r\n    ay = np.zeros(nodes)\r\n    theta_nodes = np.zeros(nodes)\r\n\r\n    # Initiate segments\r\n    segments = nodes - 1\r\n    L0 = (h_balloon - h_ground) / segments  # length of a segment\r\n\r\n    node_lst = []\r\n    for loc in loc_lst:\r\n        tandem_node = round(nodes * loc)\r\n        node_lst.append(tandem_node)\r\n        Ftandx[tandem_node - 1] = D_tandem\r\n        Ftandy[tandem_node - 1] = L_tandem\r\n    t = 0\r\n    radius_list=[]\r\n    # dt = 0.001\r\n\r\n    # plot_response(x, y)\r\n    xlist = x\r\n    ylist = y\r\n\r\n    counter = 0\r\n    max_stress = 0\r\n    while t < t_end:  # and (np.any(abs(ax) > 0.0001) or t < 0.1):\r\n        if np.all(abs(ax) < 0.01) and np.all(abs(vx) < 0.1) and t > 30:\r\n            print(\"Break because of low acceleration and speed\")\r\n            break\r\n\r\n        t += dt\r\n        counter += 1\r\n        if counter % 1000 == 0:\r\n            # update list for animation every %\"\"\r\n            xlist = np.vstack([xlist, x])\r\n            ylist = np.vstack([ylist, y])\r\n\r\n        # if counter % 1000 == 0:\r\n        #     print(f\"Has run for {t} sec in animation\")\r\n\r\n        # Calculate new area and mass\r\n        crossA = A_umpf + A_al  # m^2\r\n        r = np.sqrt(crossA / np.pi)\r\n        radius_list.append(r)\r\n        m = L0 * (rho_umpf * A_umpf + rho_al * A_al) * np.ones(nodes)\r\n        m[0] = m[0] * 0.5\r\n        m[-1] = m[-1] * 0.5\r\n        W = m * g\r\n\r\n        # Calculate tension forces in all segments\r\n        Tension = crossA * E / L0 * (np.sqrt((y[1:] - y[:-1]) ** 2 + (x[1:] - x[:-1]) ** 2) - L0)\r\n        theta = np.arctan2((x[1:] - x[:-1]), (y[1:] - y[:-1]))\r\n\r\n        Tx = Tension * np.sin(theta)\r\n        Ty = Tension * np.cos(theta)\r\n\r\n        if np.max(Tension / crossA) > max_stress and t > 10:\r\n            max_stress = np.max(Tension / crossA)\r\n\r\n        # Calculate wind force\r\n        theta_nodes[0] = theta[0]\r\n        theta_nodes[1:-1] = (theta[1:] + theta[:-1]) / 2\r\n        theta_nodes[-1] = theta[-1]\r\n\r\n        wind_speed = windspeed_from_alt(y)\r\n        if plot_wind:\r\n            Wind_l.show_wind_profile(wind_speed, y)\r\n        wind_perp = wind_speed * np.cos(theta_nodes)\r\n        wind_par = wind_speed * np.sin(theta_nodes)\r\n\r\n        Fperp = Wind_l.calc_drag_on_wire(x, y, wind_perp, L0, r, Cd)\r\n        Fperpx = Fperp * np.cos(theta_nodes)\r\n        Fperpy = Fperp * np.sin(theta_nodes)\r\n\r\n        Fpar = Wind_l.calc_drag_on_wire(x, y, wind_par, L0, r, Cd)\r\n        Fparx = Fpar * np.sin(theta_nodes)\r\n        Fpary = Fpar * np.cos(theta_nodes)\r\n\r\n        # Balloon lift and drag\r\n        D = 0.5 * ISA_general.ISA(y[[-1]])[2] * (wind_speed[-1] - vx[-1]) * abs(\r\n            wind_speed[-1] - vx[-1]) * Frontal_area * Cd_top_balloon\r\n        global L\r\n        L = np.sum(W) + excess_L - len(loc_lst) * L_tandem  # lift top balloon\r\n\r\n        # Calculate resisting forces\r\n        Fresx = C * vx\r\n        Fresy = C * vy\r\n\r\n        # Calculate total forces on all nodes\r\n        Fx[0] = Tx[0] + Fperpx[0] / 2 - Fresx[0] + Fparx[0] / 2\r\n        Fy[0] = Ty[0] - W[0] - Fresy[0] - Fperpy[0] / 2 + Fpary[0] / 2\r\n        Fx[1:-1] = Tx[1:] - Tx[0:-1] + Fperpx[1:-1] - Fresx[1:-1] + Fparx[1:-1]\r\n        Fy[1:-1] = Ty[1:] - Ty[0:-1] - W[1:-1] - Fresy[1:-1] - Fperpy[1:-1] + Fpary[1:-1]\r\n        Fx[-1] = D + Fperpx[-1] / 2 - Tx[-1] - Fresx[-1] + Fparx[-1] / 2\r\n        Fy[-1] = L - Ty[-1] - W[-1] - Fresy[-1] - Fperpy[-1] / 2 + Fpary[-1] / 2\r\n\r\n        # Add tandem forces\r\n        # def update_tandem(cd_tandem):\r\n        #     for i in range(len(loc_lst)):\r\n        #         vol, rho = tandem_volume(y[node_lst[i]], L_tandem)\r\n        #         R = (vol * 3 / 4 / np.pi) ** (1 / 3)\r\n        #         D_tandem = cd_tandem * 0.5 * rho * (wind_speed[node_lst[i]] - vx[node_lst[i]]) * abs(\r\n        #             (wind_speed[node_lst[i]] - vx[node_lst[i]])) * np.pi * R ** 2\r\n        #         Ftandx[tandem_node] = D_tandem\r\n        # if counter % 100 == 0:\r\n        #     update_tandem(Cd_tan_balloon)\r\n\r\n        if counter % 100 == 0:\r\n            update_tandem(Cd_tan_balloon)\r\n        Fx = Fx + Ftandx  # note! these are 2 vectors\r\n        Fy = Fy + Ftandy  # note! these are 2 vectors\r\n\r\n        ax[1:] = Fx[1:] / m[1:] * min(t, 1)\r\n        ay[1:] = Fy[1:] / m[1:] * min(t, 1)\r\n\r\n        if t > 10 and counter % 10000 == 0:\r\n            A_umpf = A_umpf * np.max(Tension / A_umpf) / sigma_max\r\n            print(f'Area of the UHMWPE is {A_umpf} m^2')\r\n            # L += (250e6 - np.max(Tension / crossA)) * crossA\r\n\r\n        vx = vx + ax * dt\r\n        vy = vy + ay * dt\r\n\r\n        x = x + vx * dt\r\n        y = y + vy * dt\r\n        plot_wind = False\r\n    return xlist, ylist, max_stress, Tension / crossA, L\r\n\r\n\r\nwind_profile_select = 2\r\nt_end = 100\r\nxlists = []\r\nylists = []\r\nmax_stress_list = []\r\nend_tension_list = []\r\nend_lift_list = []\r\n\r\n### animation ###\r\n\r\nanimations = 2\r\ncd_items = [0.3, 0.3, 0.3, 0.3]  # drag coeff of tether\r\nexcess_L_list = [5000, 5000, 5000, 5000]  # excess lift of top balloon\r\nradius_items = [0.004, 0.007, 0.006, 0.007]  # radius of tether\r\nheight_items = [20000, 20000, 20000, 20000]  # top balloon height\r\nnode_amount = [75, 75, 75, 75]  # amount of nodes to use\r\ndt_list = [0.0025, 0.0025, 0.005, 0.01]\r\nloc_lsts = [[], [], [], []]  # fraction on where tendem balloon is located\r\nfor i in range(animations):\r\n    begin_time = time.time()\r\n    excess_L = excess_L_list[i]  # N - excess lift\r\n    xlist, ylist, max_stress, End_Tension, end_lift = run_progamm(Cd=cd_items[i], r=radius_items[i], h_balloon=height_items[i],\r\n                                                        nodes=node_amount[i], loc_lst=loc_lsts[i], dt=dt_list[i])\r\n    xlists.append(xlist)\r\n    ylists.append(ylist)\r\n    max_stress_list.append(max_stress / 10 ** 6)\r\n    end_tension_list.append(End_Tension)\r\n    end_lift_list.append(end_lift)\r\n    time_in_sec = round(time.time() - begin_time)\r\n    time_in_min = 0\r\n    if time_in_sec>59:\r\n        time_in_min = round((time.time() - begin_time)/60)\r\n    time_in_sec -= time_in_min*60\r\n    print(f\"Done with tether {i + 1}, it took {time_in_min} min and {time_in_sec} sec\")\r\nprint(max_stress_list)\r\nbegin_time = time.time()\r\n\r\n\r\ndef animate(i):\r\n    item_list = []\r\n    for item in range(animations):  # get animation number\r\n\r\n        # get correct object from the lists for current animation\r\n        line = lines[item]\r\n        balloon = balloons[item]\r\n        xlist = xlists[item]\r\n        ylist = ylists[item]\r\n\r\n        # if already done reprint last state\r\n        if i >= len(xlist):\r\n            x = xlist[-1]\r\n            y = ylist[-1]\r\n        else:  # otherwise update to next frame\r\n            x = xlist[i]\r\n            y = ylist[i]\r\n\r\n        balloon_x = x[-1]  # top item = top balloon\r\n        balloon_y = y[-1]\r\n        line.set_data(x, y)  # update the data.\r\n        balloon.set_data(balloon_x, balloon_y)\r\n        # add to objects list\r\n        item_list.append(line)\r\n        item_list.append(balloon)\r\n\r\n        # now for tand balloons\r\n        loc_lst = loc_lsts[item]\r\n        tand_x = []\r\n        tand_y = []\r\n        if loc_lst:\r\n            tand_balloon = tand_balloons[item]\r\n            for loc_frac in loc_lst:  # loop\r\n                loc = round(loc_frac * len(x))\r\n                tand_x.append(x[loc])\r\n                tand_y.append(y[loc])\r\n            tand_balloon.set_data(tand_x, tand_y)\r\n            item_list.append(tand_balloon)\r\n\r\n    # time text update\r\n    time_text.set_text(time_template % (i))\r\n\r\n    item_list.append(time_text)\r\n\r\n    return tuple(item_list)\r\n\r\n\r\n# define plot scales for animation\r\n# max_x_value = 0\r\n# min_x_value = 0\r\n\r\n# for i in range(len(xlists)):\r\n#     for xlist in xlists[i]:\r\n#         for x_time_list in xlists:\r\n#             for xnodes in x_time_list:\r\n#                 for x in xnodes:\r\n#                     if x > max_x_value:\r\n#                         max_x_value = x\r\n#                     if x < min_x_value:\r\n#                         min_x_value = x\r\n\r\nfig = plt.figure()\r\ntitle = f\"Final dynamic response to wind profile {wind_profile_select}\\n\" \\\r\n        f\" animated for a total of {t_end} [sec]\"\r\naxis = plt.axes(xlim=(-100, 20000 + 2000), xlabel=\"Horizontal distance [meters]\",\r\n                ylim=(-100, 20000 + 2000), ylabel=\"Altitude [meters]\", title=title)\r\n\r\n# make lists for objects\r\nlines = []\r\nballoons = []\r\ntand_balloons = []\r\n\r\n# initialize objects\r\nfor item in range(animations):\r\n    label = f\"Tether {item + 1}, Cd = {cd_items[item]}, radius = {radius_items[item]}, excess Lift = {excess_L_list[item]}\"\r\n    line, = axis.plot([], [], c=colorlist[item], label=label)\r\n    balloon, = axis.plot([], [], marker='.', linestyle=\"None\", label=f\"Balloon {item + 1}\", c=\"black\", markersize=20)\r\n    if loc_lsts[item]:\r\n        tand_balloon, = axis.plot([], [], marker='.', linestyle=\"None\", label=f\"tand_balloons {item + 1}\", c=\"gray\",\r\n                                  markersize=10)\r\n        tand_balloons.append(tand_balloon)\r\n    lines.append(line)\r\n    balloons.append(balloon)\r\n\r\n# initialize time text\r\ntime_template = 'time= %.1fs'\r\ntime_text = axis.text(00.5, 0.9, \"\")\r\n\r\ngridlines_big = axis.grid(which=\"major\")\r\nlegend = plt.legend()\r\n\r\n# check longest time duration\r\nt_longest = 0\r\nfor i in xlists:\r\n    if len(i) > t_longest:\r\n        t_longest = len(i)\r\n\r\nani = animation.FuncAnimation(fig, animate, frames=t_longest, interval=60, blit=True)\r\n\r\n# save animation to Animations folder\r\nname = f'prr {t_longest}'\r\nsave_name = (\"./Animations/\" + name + \".gif\")\r\nprint(f\"Animating took {time.time() - begin_time} [sec]\")\r\nani.save(save_name, dpi=300, writer=PillowWriter(fps=25))\r\nplt.show()\r\nplot_response(xlists, ylists, loc_lsts, end_tension_list, end_lift_list)\r\n\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/dynamic tether simulation.py b/dynamic tether simulation.py
--- a/dynamic tether simulation.py	(revision c25e50271754c824309b7efccd1997adc2b9c9a2)
+++ b/dynamic tether simulation.py	(date 1673623910604)
@@ -102,7 +102,7 @@
     # loc_lst = [0.2]  # Fractions of the tether where the tandem balloon is located
 
     rho_umpf = 950  # UHMWPE density, kg/m^3
-    rho_al = 70  # aluminium density, kg/m^3
+    rho_al = 2710  # aluminium density, kg/m^3
     A_umpf = 100e-6  # initial guess, m^2
     A_al = 16e-6  # m^2
     sigma_max = 250e6  # maximum allowable stress, Pa
@@ -208,6 +208,8 @@
         Fresx = C * vx
         Fresy = C * vy
 
+
+
         # Calculate total forces on all nodes
         Fx[0] = Tx[0] + Fperpx[0] / 2 - Fresx[0] + Fparx[0] / 2
         Fy[0] = Ty[0] - W[0] - Fresy[0] - Fperpy[0] / 2 + Fpary[0] / 2
@@ -250,7 +252,7 @@
 
 
 wind_profile_select = 2
-t_end = 100
+t_end = 300
 xlists = []
 ylists = []
 max_stress_list = []
@@ -261,7 +263,7 @@
 
 animations = 2
 cd_items = [0.3, 0.3, 0.3, 0.3]  # drag coeff of tether
-excess_L_list = [5000, 5000, 5000, 5000]  # excess lift of top balloon
+excess_L_list = [5000, 10000, 5000, 5000]  # excess lift of top balloon
 radius_items = [0.004, 0.007, 0.006, 0.007]  # radius of tether
 height_items = [20000, 20000, 20000, 20000]  # top balloon height
 node_amount = [75, 75, 75, 75]  # amount of nodes to use
@@ -393,4 +395,5 @@
 ani.save(save_name, dpi=300, writer=PillowWriter(fps=25))
 plt.show()
 plot_response(xlists, ylists, loc_lsts, end_tension_list, end_lift_list)
+print(max_stress)
 
Index: .idea/DSE_Group3_Q2_2022.iml
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+><?xml version=\"1.0\" encoding=\"UTF-8\"?>\r\n<module type=\"PYTHON_MODULE\" version=\"4\">\r\n  <component name=\"NewModuleRootManager\">\r\n    <content url=\"file://$MODULE_DIR$\">\r\n      <excludeFolder url=\"file://$MODULE_DIR$/venv\" />\r\n    </content>\r\n    <orderEntry type=\"jdk\" jdkName=\"Python 3.9\" jdkType=\"Python SDK\" />\r\n    <orderEntry type=\"sourceFolder\" forTests=\"false\" />\r\n  </component>\r\n</module>
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/.idea/DSE_Group3_Q2_2022.iml b/.idea/DSE_Group3_Q2_2022.iml
--- a/.idea/DSE_Group3_Q2_2022.iml	(revision c25e50271754c824309b7efccd1997adc2b9c9a2)
+++ b/.idea/DSE_Group3_Q2_2022.iml	(date 1673618528121)
@@ -4,7 +4,7 @@
     <content url="file://$MODULE_DIR$">
       <excludeFolder url="file://$MODULE_DIR$/venv" />
     </content>
-    <orderEntry type="jdk" jdkName="Python 3.9" jdkType="Python SDK" />
+    <orderEntry type="jdk" jdkName="Python 3.1" jdkType="Python SDK" />
     <orderEntry type="sourceFolder" forTests="false" />
   </component>
 </module>
\ No newline at end of file
Index: .idea/misc.xml
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+><?xml version=\"1.0\" encoding=\"UTF-8\"?>\r\n<project version=\"4\">\r\n  <component name=\"ProjectRootManager\" version=\"2\" project-jdk-name=\"Python 3.9\" project-jdk-type=\"Python SDK\" />\r\n</project>
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/.idea/misc.xml b/.idea/misc.xml
--- a/.idea/misc.xml	(revision c25e50271754c824309b7efccd1997adc2b9c9a2)
+++ b/.idea/misc.xml	(date 1673618528145)
@@ -1,4 +1,4 @@
 <?xml version="1.0" encoding="UTF-8"?>
 <project version="4">
-  <component name="ProjectRootManager" version="2" project-jdk-name="Python 3.9" project-jdk-type="Python SDK" />
+  <component name="ProjectRootManager" version="2" project-jdk-name="Python 3.1" project-jdk-type="Python SDK" />
 </project>
\ No newline at end of file
